# 1、观察者模式
[漫画：什么是“观察者模式”？](https://zhuanlan.zhihu.com/p/158537313)

观察者模式，有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

[C#——观察者模式](https://blog.csdn.net/YJF19997/article/details/117921378)

# 2、迭代器模式

[秒懂设计模式之迭代器模式（Iterator Pattern)](https://zhuanlan.zhihu.com/p/382360388)

[c#之迭代器模式-01](https://zhuanlan.zhihu.com/p/413934831)

[对Unity中Coroutines(协程)的理解](https://wuzhiwei.net/unity_coroutines/)

# 3、单例模式

## 3.1懒汉式-非线程安全

**懒汉式——在程序执行过程中第一次需要时再实例化**
**这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁，所以严格意义上它并不算单例模式。
这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。**

```cs
/// <summary>
/// Bad code！Do not use! 
/// </summary>
public sealed class Singleton//sealed 密封类关键字
{
    private static Singleton instance = null;// 定义一个静态变量来保存类的实例
    private Singleton() { }// 定义私有构造函数，使外界不能创建该类实例
    public static Singleton Instance
    {
        get
        {
           //如果类的实例不存在则创建，否则直接返回
           if (instance == null)
           {
                instance = new Singleton();
           }
           return instance;
        }
    }
}
```
该版本在多线程下是不安全的，会创建多个实例，请不要在生产环境中使用！

因为如果两个线程同时运行到if(instance==null)判断时，就会创建两个实例，这是违背单例模式的初衷的。实际上在后面那个线程进行判断是已经生成了一个实例，但是对于不同的线程来说除非进行了线程间的通信，否则它是不知道的。

## 3.2懒汉式-简单线程安全
**这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
优点：第一次调用才初始化，避免内存浪费。
缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。**
```cs
public sealed class Singleton2
{
    private static Singleton2 instance = null;
    private static readonly object obj = new object();//创建锁对象
    private Singleton2() { }
    public Singleton2 Instance
    {
        get
        {
            // 当第一个线程运行到这里时，此时会对locker对象 "加锁"，
            // 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁
            // lock语句运行完之后（即线程运行完之后）会对该对象"解锁"
            lock (obj)//互斥锁
            {
                if (instance == null)
                {
                    instance = new Singleton2();
                }
                return instance;
            }
        }
    }
}
```
该版本是线程安全的。通过对一个过线程共享的对象进行加锁操作，保证了在同一时刻只有一个线程在执行lock{}里的代码。当第一个线程在进行instance判断或创建时，后续线程必须等待直到前一线程执行完毕，因此保证了只有第一个线程能够创建instance实例。

但不幸的是，因为每次对instance的请求都会进行lock操作，其性能是不佳的。

需要注意的是，这里使用了一个private static object变量进行锁定，这是因为当如果对一个外部类可以访问的对象进行锁定时会导致性能低下甚至死锁。因此通常来说为了保证线程安全，进行加锁的对象应该是private的。

## 3.3懒汉式-双检锁/双重校验锁（DCL）
**这种方式采用双锁机制，安全且在多线程情况下能保持高性能。**
```cs
public class Singleton
{
    private static Singleton uniqueInstance;

    private static readonly object locker = new object();

    private Singleton() { }


    public static Singleton GetInstance()
    {
        if (uniqueInstance == null)
        {
            lock (locker)
            {
                if (uniqueInstance == null)
                {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
     }
}
```
上面这种解决方案确实可以解决多线程的问题,但是上面代码对于每个线程都会对线程辅助对象locker加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（uniqueInstance==null）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能，为了改进上面实现方式的缺陷，我们只需要在lock语句前面加一句（uniqueInstance==null）的判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它 “双重锁定”

```cs
public class LazySingleton
{
    private static readonly Lazy<LazySingleton> _instance =
        new Lazy<LazySingleton>(() => new LazySingleton());

    public static LazySingleton Instance
    {
        get { return _instance.Value; }
    }
}

//调用示例
public class Program
{
    public static void Main()
    {
        var instance = LazySingleton.Instance;
    }
}
```
在 C# 3.5 的时候，就有了更好的写法，使用 `Lazy<T>`。
使用 `Lazy<T>`可以使对象的实例化延迟到第一次被调用的时候执行，通过访问它的 Value 属性来创建并获取实例，并且读取一个`Lazy<T>` 实例的 Value 属性只会执行一次实例化代码，确保了线程安全。

## 3.4 饿汉式

**在静态构造函数中立即进行实例化**
**这种方式比较常用，但容易产生垃圾对象。
优点：没有加锁，执行效率会提高。
缺点：类加载时就初始化，浪费内存。**

```cs
public class Singleton
{
    private static readonly Singleton _instance = new Singleton();
    public static Singleton Instance
    {
        get
        {
            return _instance;
        }
    }
}

//在C#7后可以进一步简写为
public class Singleton
{
    public static Singleton Instance { get; } = new Singleton();
}
```

# 4、状态模式

# 5、外观模式

[漫画：设计模式之 “外观模式”](https://zhuanlan.zhihu.com/p/180030007)